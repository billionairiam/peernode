

---

### 1. `--no-pivot`

**首先，理解默认行为：使用 `pivot_root`**

-   `pivot_root` 是一个 Linux 系统调用，是实现容器文件系统隔离的**最强力、最安全**的方式。
-   它的作用是把容器进程的根文件系统（`/`）彻底切换到你为容器准备的 `rootfs` 目录。
-   想象一下：`chroot` 命令是把你“关在”一个新目录里，但你仍然知道外面还有一个“真实”的根目录。而 `pivot_root` 则更进一步，它让你所在的 `rootfs` **变成** 整个世界的根，旧的根目录会被移走，使得容器内的进程完全无法访问或感知到宿主机的原始文件系统。
-   这是实现强隔离的关键技术。默认情况下，`runc` 总是会尝试使用 `pivot_root`。

**`--no-pivot` 的作用是什么？**

-   这个标志告诉 `runc`：“**不要使用 `pivot_root` 系统调用**”。
-   当使用此标志时，`runc` 会退而求其次，使用一个功能上较弱但兼容性更好的替代方案，通常是 `chroot`。

**为什么会需要它？（使用场景）**

-   `pivot_root` 有一个重要的限制：**新的根目录和旧的根目录不能在同一个挂载点上**。
-   在绝大多数标准的 Linux 系统上，这不是问题。但有些特殊环境会违反这个限制，例如：
    -   **Ramdisk / initramfs 环境**: 在系统启动的早期阶段，整个系统可能都运行在一个内存文件系统（ramdisk）中，此时只有一个挂载点。在这种环境下运行容器，`pivot_root` 会失败。
    -   **某些嵌入式或精简的系统**: 系统设计可能非常简单，不符合 `pivot_root` 的要求。
-   如 `runc` 的帮助信息所说，`This should be used whenever the rootfs is on top of a ramdisk`。
-   **总结**：`--no-pivot` 是一个兼容性选项，用于在 `pivot_root` 无法工作的特殊环境中创建容器，代价是牺牲了一点文件系统的隔离强度。

**与 Go 代码的关联**:

```go
if o.NoPivot {
    out = append(out, "--no-pivot")
}
```

这段代码直接将 `CreateOpts` 结构体中的 `NoPivot` 布尔值映射到 `--no-pivot` 命令行标志。

---

### 2. `--no-new-keyring`

**首先，理解默认行为：创建新的会话密钥环（Session Keyring）**

-   Linux 内核有一个“密钥环”（Keyring）机制，用于在内核中安全地缓存和管理安全凭证，如加密密钥、身份验证令牌等。
-   一个“会话密钥环”与一个用户的登录会话关联。
-   出于安全考虑，当 `runc` 创建一个新容器时，默认会为这个容器**创建一个全新的、空的会话密钥环**。
-   这样做的好处是**隔离**：容器无法访问宿主机上（即调用 `runc` 的那个进程）的任何密钥或令牌，防止了敏感信息的泄露。

**`--no-new-keyring` 的作用是什么？**

-   这个标志告诉 `runc`：“**不要为容器创建新的会话密钥环**”。
-   结果是，容器内的进程会**继承**其父进程（即 `runc` 进程）的会话密钥环。

**为什么会需要它？（使用场景）**

-   当容器内的应用**需要使用**宿主机上已经存在的密钥时。
-   **典型例子**：一个企业环境中使用 Kerberos 进行身份认证。用户在宿主机上登录时获取了一个 Kerberos 票据（ticket），这个票据被存储在会话密钥环中。现在，你想启动一个容器，让容器内的应用使用这个**已有的票据**去访问网络服务，而不需要在容器内再次进行复杂的认证流程。
-   **总结**：`--no-new-keyring` 打破了密钥环的隔离，是一种“特权”操作，允许容器访问宿主机的安全凭证。只有在明确需要这种继承关系时才应使用。

**与 Go 代码的关联**:

```go
if o.NoNewKeyring {
    out = append(out, "--no-new-keyring")
}
```

同样，`CreateOpts` 中的 `NoNewKeyring` 布尔值直接控制是否添加 `--no-new-keyring` 标志。

---

### 3. `--preserve-fds value`

**首先，理解默认行为：只保留标准 I/O 文件描述符**

-   在 Linux 中，当一个进程创建子进程时，子进程默认会继承父进程所有打开的**文件描述符**（File Descriptors, FDs）。文件描述符就是指向打开的文件、管道（pipe）、套接字（socket）等的整数句柄。
-   为了保证容器的干净和安全，`runc` 的默认行为是**关闭所有继承来的文件描述符**，只为容器保留最基本的三个：
    -   `0`: 标准输入 (stdin)
    -   `1`: 标准输出 (stdout)
    -   `2`: 标准错误 (stderr)

**`--preserve-fds value` 的作用是什么？**

-   这个标志告诉 `runc`：“**除了标准I/O的3个FD之外，请再额外保留 `value` 个文件描述符，并把它们传递给容器内的进程**”。
-   这些额外的文件描述符会从 `3` 开始依次编号。例如，`--preserve-fds 2` 会保留 FD 3 和 FD 4。
-   `value` 是一个**整数**，代表要保留的**额外**文件描述符的数量。

**为什么会需要它？（使用场景）**

这是一个非常强大的功能，常用于“**套接字激活**”（Socket Activation）等高级模式。

-   **场景1：传递网络套接字**
    1.  容器编排器（如 containerd 或 CRI-O）在宿主机上创建一个监听网络端口的套接字（比如监听 `8080` 端口）。
    2.  然后它调用 `runc create`，并使用 `--preserve-fds 1` 将这个监听套接字的文件描述符（比如是 FD 3）传递给容器。
    3.  容器内的 Web 服务器（如 Nginx）启动时，不需要自己去绑定 `8080` 端口（这可能需要特权），而是直接从继承来的文件描述符 `3` 上开始接受连接。
    4.  **好处**：实现了权限分离（绑定端口的操作由外部完成），并且可以实现零停机更新（编排器可以先启动一个新容器，把套接字传给它，然后再关闭旧容器）。

-   **场景2：传递数据库连接**
    一个宿主机上的应用可以建立好到一个数据库的安全连接，然后把这个连接的套接字文件描述符传递给容器。容器内的应用无需知道数据库的密码，直接就可以使用这个已经建立好的连接。

**与 Go 代码的关联**:

```go
if o.ExtraFiles != nil {
    out = append(out, "--preserve-fds", strconv.Itoa(len(o.ExtraFiles)))
}
// ... 稍后 ...
cmd.ExtraFiles = opts.ExtraFiles
```

这里的实现非常巧妙：
1.  `opts.ExtraFiles` 是一个 `[]*os.File` 类型的切片，它包含了调用者希望传递给容器的实际文件对象。
2.  `strconv.Itoa(len(o.ExtraFiles))` 计算出要传递的文件数量，并将其作为 `--preserve-fds` 的值。
3.  `cmd.ExtraFiles = opts.ExtraFiles` 则是利用 Go `os/exec` 包的原生功能，将这些文件描述符真正地附加到即将执行的 `runc` 命令上。

这完美地展示了如何将一个高级的 Go 语言概念（文件对象切片）映射到底层的 Linux 进程创建机制上。